<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>andavid&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://andavid.github.io/"/>
  <updated>2019-01-21T04:53:59.027Z</updated>
  <id>https://andavid.github.io/</id>
  
  <author>
    <name>andavid</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 简明指南</title>
    <link href="https://andavid.github.io/2019/01/16/git-guide/"/>
    <id>https://andavid.github.io/2019/01/16/git-guide/</id>
    <published>2019-01-16T08:48:18.000Z</published>
    <updated>2019-01-21T04:53:59.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/16/git-guide/git.jpeg" alt=""></p><p>本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。</p><a id="more"></a><h2 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录（workspace），它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。</p><p><img src="/2019/01/16/git-guide/trees.png" alt=""></p><p>git 状态的转换如下图所示：</p><p><img src="/2019/01/16/git-guide/workflow.jpg" alt=""></p><h2 id="Git-内部实现原理"><a href="#Git-内部实现原理" class="headerlink" title="Git 内部实现原理"></a>Git 内部实现原理</h2><p>Git 是一个内容寻址文件系统。</p><p>Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p><p>每一次提交对应 .git/objects 目录下的一个文件。以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>所有的提交以树的方式组织在一起。</p><p>HEAD, master, 分支名，标记，都是一个指针指向某一次提交。</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>了解以上 Git 工作流和 Git 内部实现原理，有助于更好的使用 Git。为了更好的使用 Git，需要对 Git 进行一些简单的配置。</p><p>查看当前配置的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --lis</span><br></pre></td></tr></table></figure><p>设置提交用户名和邮箱：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;mail@gmail.com&quot;</span><br></pre></td></tr></table></figure><p>设置所有的 git pull 命令使用 git rebase 而不是 git merge：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global pull.rebase true</span><br></pre></td></tr></table></figure><p>设置别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias.st=status</span><br><span class="line">alias.br=branch</span><br><span class="line">alias.unstage=reset HEAD</span><br><span class="line">alias.last=log -1</span><br><span class="line">alias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class="line">alias.co=checkout</span><br><span class="line">alias.cm=commit -m</span><br></pre></td></tr></table></figure><p>其他配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color.ui=true</span><br><span class="line">core.quotepath=false</span><br><span class="line">core.autocrlf=input</span><br></pre></td></tr></table></figure><p>生成 SSH Key：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后，默认保存位置当前用户名下/.ssh/id_rsa 和 id_rsa.pub，分别是私钥和公钥，可以把公钥添加到远端代码托管平台，这样在使用 Git 时就不用输入密码了。</p><p>GitHub 可以在 <code>设置 -&gt; SSH and GPG Keys</code> 添加 SSH Key。</p><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init                # 创建本地仓库</span><br><span class="line">git clone &lt;server&gt;      # 克隆远程仓库到本地</span><br></pre></td></tr></table></figure><h3 id="添加-amp-删除"><a href="#添加-amp-删除" class="headerlink" title="添加 &amp; 删除"></a>添加 &amp; 删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;              # 添加文件到暂存区</span><br><span class="line">git add .                       # 添加所有修改到暂存区</span><br><span class="line">git rm &lt;filename&gt;               # 直接删除文件</span><br><span class="line">git rm --cached &lt;filename&gt;      # 将文件从暂存区移除</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit message&quot;      # 提交修改</span><br><span class="line">git cherry-pick &lt;commit&gt;...         # 把指定 commit 合并到当前分支，会生成新的 commit</span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;     # 添加远程仓库</span><br><span class="line">git remote -v                      # 查看远程仓库</span><br><span class="line">git push origin master             # 推送到远程 master 分支</span><br><span class="line">git pull origin master             # 从远程仓库拉取更新</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch&gt;                         # 创建分支</span><br><span class="line">git checkout &lt;branch&gt;                       # 切换分支</span><br><span class="line">git checkout -b &lt;branch&gt;                    # 创建并切换到新分支</span><br><span class="line">git checkout -b &lt;branch&gt; &lt;commit&gt;           # 基于某个版本创建新分支</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;    # 创建远程分支到本地</span><br><span class="line">git branch -d &lt;branch&gt;                      # 删除本地分支</span><br><span class="line">git push origin :&lt;branch&gt;                   # 删除远程分支（推送一个空分支到远程分支）</span><br><span class="line">git push origin &lt;branch&gt;                    # 推送本地分支到远程仓库</span><br><span class="line">git merge &lt;branch&gt;                          # 合并分支</span><br><span class="line">git rebase &lt;branch&gt;                         # 分支衍合</span><br><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;      # 建立起本地分支和远程分支的关联，之后可以直接git pull从远程抓取分支</span><br><span class="line">git fetch -p        # 删除远程分支后本地分支同步</span><br></pre></td></tr></table></figure><h3 id="标记管理"><a href="#标记管理" class="headerlink" title="标记管理"></a>标记管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagName&gt;               # 基于当前 HEAD 创建标记</span><br><span class="line">git tag &lt;tagName&gt; &lt;commit&gt;      # 基于指定的 commit id 创建标记</span><br><span class="line">git tag -a &lt;tagName&gt; -m &apos;msg&apos;   # 创建带注释的标记</span><br><span class="line">git checkout &lt;tagName&gt;          # 切换到标记</span><br><span class="line">git push origin &lt;tagName&gt;       # 推送标记到远程仓库</span><br><span class="line">git tag -d &lt;tagName&gt;            # 删除本地标记</span><br><span class="line">git push origin :&lt;tagName&gt;      # 删除远程标记</span><br><span class="line">git tag -l -n1                  # 查看标记列表</span><br></pre></td></tr></table></figure><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log             # 查看提交历史</span><br><span class="line">git show &lt;commit&gt;   # 查看某次修改</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status                      # 查看工作区、暂存区的状态</span><br><span class="line">git clean -fd                   # 删除 untracked files</span><br><span class="line">git checkout -- &lt;file&gt;          # 丢弃工作区上某个文件的修改</span><br><span class="line">git checkout &lt;commit&gt; &lt;file&gt;    # 将某个文件的历史版本 checkout 到工作区</span><br><span class="line">git reset HEAD &lt;file&gt;           # 丢弃暂存区上某个文件的修改，重新放回工作区</span><br><span class="line">git reset --hard &lt;commit&gt;       # 版本回退</span><br><span class="line">git reflog                      # 查看命令历史，常用于帮助找回丢失掉的commit</span><br></pre></td></tr></table></figure><h3 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff              # 查看工作目录和暂存区之间的不同，「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」</span><br><span class="line">git diff --cached     # 查看暂存区和上一条提交之间的不同，「如果你立即输入 git commit，你将会提交什么」</span><br><span class="line">git diff HEAD         # 查看工作目录和上一条提交之间的不同，是上面两个的内容相加，「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」</span><br><span class="line">git diff HEAD -- &lt;file&gt;                     # 查看工作区和版本库里面最新版本的区别</span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only    # 比较两次提交的差异文件列表</span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs zip update.zip          #  比较两次提交的差异，并将所有差异的文件打成一个 zip 包</span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;    # 在合并改动之前，预览两个分支的差异</span><br></pre></td></tr></table></figure><h3 id="储藏和恢复"><a href="#储藏和恢复" class="headerlink" title="储藏和恢复"></a>储藏和恢复</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash           # 把当前分支所有没提交的代码储藏起来</span><br><span class="line">git stash pop       # 恢复工作现场，并删除stash内容</span><br><span class="line">git stash list      # 查看储藏的工作现场</span><br><span class="line">git stash apply     # 恢复工作现场，stash内容并不删除</span><br></pre></td></tr></table></figure><h2 id="Git-分支管理流程"><a href="#Git-分支管理流程" class="headerlink" title="Git 分支管理流程"></a>Git 分支管理流程</h2><p><img src="/2019/01/16/git-guide/git-flow.png" alt=""></p><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>master 分支对应当前生产代码，严禁直接在这个分支上进行开发和提交。</p><h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><ul><li>develop 分支基于 master 分支创建。</li><li>对应开发主分支，只用于做代码同步，不能直接在这个分支进行开发和提交。</li></ul><h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><ul><li>feature 分支基于 develop 分支创建。</li><li>feature 分支用于新功能的开发、bug 修复等日常开发。</li><li>使用 git rebase develop 命令及时合并 develop 分支最新代码，防止和 develop 分支越走越远。</li><li>当合并 develop 分支有冲突时，在 feature 分支进行解决。</li><li>feature 分支开发完成后被合并到 develop 分支。</li></ul><h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><ul><li>release 分支基于 develop 分支创建。</li><li>release 分支作为待发布分支，在这个分支进行回归测试和测试问题的修复。</li><li>release 分支开发完成后被合并到 develop 和 master 分支。</li></ul><h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><ul><li>hotfix 分支基于 master 分支创建。</li><li>hotfix 分支用于生产问题的紧急修复。</li><li>hotfix 分支开发完成后被合并到 develop 和 master 分支。</li></ul><h2 id="代码提交规范"><a href="#代码提交规范" class="headerlink" title="代码提交规范"></a>代码提交规范</h2><ul><li>不在 dev 开发主分支上直接做提交。</li><li>基于 dev 分支创建本地 feature 分支进行提交，包括新功能的开发、bug 修复等。</li><li>每天从服务端拉取 dev 分支最新代码。</li><li>在本地 feature 分支使用 <code>git rebase dev</code> 命令及时合并 dev 分支最新代码，防止本地分支和 dev 分支越走越远。当合并有冲突时，在本地 feature 分支进行解决</li><li>提交代码之前先在本地进行测试，确保项目能编译通过，且能够正常运行，不可盲目提交。</li><li>提交必须要有注释，简要说明本次提交内容。</li><li>尽量提交原子级的操作，便于恢复。不要一次提交 N 多个文件，然后注释写很长还分好几点，如果是这种情况，建议分成多次提交。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/01/16/git-guide/git.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://andavid.github.io/categories/Git/"/>
    
    
      <category term="git-guide" scheme="https://andavid.github.io/tags/git-guide/"/>
    
      <category term="git-flow" scheme="https://andavid.github.io/tags/git-flow/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 中完美插入本地图片</title>
    <link href="https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/"/>
    <id>https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/</id>
    <published>2019-01-15T05:54:39.000Z</published>
    <updated>2019-01-21T04:54:21.403Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/15/insert-local-image-in-hexo/preview.png" alt=""></p><p>在 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">资源文件夹章节</a> 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。</p><a id="more"></a><h2 id="Hexo-官方插入本地图片方法"><a href="#Hexo-官方插入本地图片方法" class="headerlink" title="Hexo 官方插入本地图片方法"></a>Hexo 官方插入本地图片方法</h2><p>首先来看官方给出的几种方式。</p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们统一放在 <code>source/images</code> 文件夹中。然后通过以下方法进行访问。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](/imges/image.jpg)</span><br></pre></td></tr></table></figure><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>图片除了可以放在统一的 <code>source/images</code> 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置  <code>_config.yml</code> 来生成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code> 后，执行命令 <code>hexo new post_name</code>，在 <code>source/_posts</code> 中会生成文章  <code>post_name.md</code> 和同名文件夹 <code>post_name</code>。将图片资源放在  <code>post_name</code> 中，文章就可以使用相对路径引用图片资源了。引用图片的方法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>以上这种引用方法，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><p>引用语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></p><p>在上述语法下，引用图片的方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h2 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h2><p>无论是以上哪一种方法，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a>。先将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code>，然后在根目录下执行以下命令进行插件的安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>通过 <code>hexo new post_name</code> 命令，在 <code>source/_posts</code> 中会自动生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code>，把所有需要插入的图片放到这个同名文件夹里，通过 Markdown 语法对图片的相对路径引用，即可实现编辑时可预览图片，引用方法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](post_name/image.jpg)</span><br></pre></td></tr></table></figure><p>然后在发布时 <code>hexo-asset-image</code> 插件会自动将相对路径转为绝对路径，保证在文章和主页以及归档页都能正常显示图片。</p><p>但是，这个插件有个小问题，如果网站部署在子目录下，插件生成的图片路径有问题，导致图片无法显示。需要修改插件。插件代码主要保存在 <code>node_modules/hexo-asset-image/index.js</code> 这个文件，以下是其中一段代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></figure><p>根据文章链接截取得到 link，其中文章链接一般都是 <code>http://host:port/yyyy/mm/dd/post_name</code>，从第三个 <code>/</code> 后面取到的就是资源的绝对路径，然后对图片的 src 属性进行处理，去掉文章同名文件夹目录，仅保留图片名，然后与前面获取到的资源绝对路径进行拼接，得到图片的绝对路径。</p><p>如果网站部署在子目录下，文章链接是这样的：<br><code>http://host:port/subdirectory/yyyy/mm/dd/post_name</code><br>这时应该从第四个 <code>/</code> 后面开始截取。因此，将代码修改如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">var</span> rootArray = config.root.split(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">2</span> + rootArray.length - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></figure><p>为了使修改后的插件生效，需要先执行 <code>hexo clean</code> 清理一下，然后再执行 <code>hexo g</code> 重新生成即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Hexo 官方插入本地图片的三种方法，但是不推荐使用，因为在使用其他 Markdown 编辑器进行文章编写时，无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 <code>hexo-asset-image</code>，在生成网站时自动将图片相对路径转为绝对路径，使得在文章和主页以及归档页都能正常显示图片。最后，通过修改插件代码，解决网站部署在子目录下图片无法显示的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/01/15/insert-local-image-in-hexo/preview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 Hexo 的官方文档 &lt;a href=&quot;https://hexo.io/zh-cn/docs/asset-folders.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;资源文件夹章节&lt;/a&gt; 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://andavid.github.io/categories/Hexo/"/>
    
    
      <category term="hexo-insert-local-image" scheme="https://andavid.github.io/tags/hexo-insert-local-image/"/>
    
  </entry>
  
</feed>
