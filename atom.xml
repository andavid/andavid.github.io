<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JK Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://andavid.github.io/"/>
  <updated>2019-07-15T01:56:21.114Z</updated>
  <id>https://andavid.github.io/</id>
  
  <author>
    <name>andavid</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JsBridge 源码解析</title>
    <link href="https://andavid.github.io/2019/03/25/js-bridge/"/>
    <id>https://andavid.github.io/2019/03/25/js-bridge/</id>
    <published>2019-03-25T09:43:51.000Z</published>
    <updated>2019-07-15T01:56:21.114Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了 JsBridge 的使用，并基于源码详细分析了 JS 和 Native 的相互调用流程。最后，简单谈了谈对 JsBridge 的一些理解，包括其通信机制、实现逻辑等。</p><a id="more"></a><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>项目地址：<a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">https://github.com/lzyzsd/JsBridge</a></p><p>JsBridge 是一座用 JavaScript 搭建起来的桥，桥的两端分别是 Native 和 Web。这座桥实现了 Java 和 JavaScript 的数据交换，即 Native 端可以调 Web 的 JS 代码，JS 端也可以调用 Native 的原生代码。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>这个库会在  <code>onPageFinished</code>  加载一个 JS 文件 <code>WebViewJavascriptBridge.js</code>，这会向 window 对象注入一个 WebViewJavascriptBridge 对象，因此在 JS 中使用 WebViewJavascriptBridge 对象时需检查它是否已经注入，可以通过监听 <code>WebViewJavascriptBridgeReady</code> 事件来实现。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    callback(WebViewJavascriptBridge);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">'WebViewJavascriptBridgeReady'</span></span><br><span class="line">      , <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(WebViewJavascriptBridge)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS-调-Native"><a href="#JS-调-Native" class="headerlink" title="JS 调 Native"></a>JS 调 Native</h3><p>以下是一个例子，实现按下物理返回键时响应 WebView 的 JS 方法。</p><p>首先，在 Native 端通过 registerHandler 方法注册一个设置物理返回键监听的接口供 JS 调用，当按下物理返回键时执行 JS 回调：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webview.registerHandler(<span class="string">"setPhysicalBackListener"</span>, <span class="keyword">new</span> BridgeHandler() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">final</span> String data, <span class="keyword">final</span> CallBackFunction function)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set physical back key listener</span></span><br><span class="line">    <span class="comment">// execute function.onCallBack(responseData) when user click physical back key</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，在 JS 端通过 callHandler 方法调用 Native：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">  bridge.callHandler(</span><br><span class="line">    <span class="string">'setPhysicalBackListener'</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"back key pressed "</span> + responseData);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>JSBridge 也提供了无方法名的调用方式。</p><p>首先需要在 Native 端设置一个默认的 Handler：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.setDefaultHandler(<span class="keyword">new</span> DefaultHandler());</span><br></pre></td></tr></table></figure><p>然后，在 JS 端通过 send 方法调用 Native：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.WebViewJavascriptBridge.send(</span><br><span class="line">  data,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Native-调-JS"><a href="#Native-调-JS" class="headerlink" title="Native 调 JS"></a>Native 调 JS</h3><p>以下是一个例子，实现在 Native 端调用在 JS 中定义的 JS 函数。</p><p>首先，在 JS 端通过 registerHandler 方法注册一个 Handler：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">  bridge.registerHandler(</span><br><span class="line">    <span class="string">"functionInJs"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"show"</span>).innerHTML = (<span class="string">"data from Java: = "</span> + data);</span><br><span class="line">      <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="keyword">var</span> responseData = <span class="string">"Javascript Says Right back aka!"</span>;</span><br><span class="line">        responseCallback(responseData);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，在 Native 端通过 callHandler 方法调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.callHandler(<span class="string">"functionInJs"</span>, <span class="keyword">new</span> Gson().toJson(user), <span class="keyword">new</span> CallBackFunction() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"reponse data from js "</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样的，JSBridge 也提供了无方法名的调用方式。</p><p>首先需要在 JS 端设置一个默认的 Handler：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">  bridge.init(<span class="function"><span class="keyword">function</span>(<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'JS got a message'</span>, message);</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      <span class="string">'Javascript Responds'</span>: <span class="string">'hello'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'JS responding with'</span>, data);</span><br><span class="line">      responseCallback(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，在 Native 端通过 send 方法调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.send(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="核心类分析"><a href="#核心类分析" class="headerlink" title="核心类分析"></a>核心类分析</h3><p>核心的 Java 类主要有两个：<code>BridgeWebView</code> 和 <code>BridgeWebViewClient</code>。</p><p>另外，还有一个 <code>WebViewJavascriptBridge.js</code>，主要的 JS 代码都在这个 JS 文件里。</p><p>先来看 <code>BridgeWebView</code> 的构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BridgeWebView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(context);</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setVerticalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.setHorizontalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setWebViewClient(generateBridgeWebViewClient());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BridgeWebViewClient <span class="title">generateBridgeWebViewClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BridgeWebViewClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化时设置了一个自定义的 WebViewClient。</p><p>接下来看看 <code>BridgeWebViewClient</code> 这个类：</p><p>在  <code>onPageFinished</code>  加载 JS 文件 <code>WebViewJavascriptBridge.js</code>，如果有未发送的消息，挨个取出进行分发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BridgeWebView.toLoadJs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (webView.getStartupMessage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Message m : webView.getStartupMessage()) &#123;</span><br><span class="line">      webView.dispatchMessage(m);</span><br><span class="line">    &#125;</span><br><span class="line">    webView.setStartupMessage(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>shouldOverrideUrlLoading</code> 方法拦截特殊格式的 url，执行 Native 代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    url = URLDecoder.decode(url, <span class="string">"UTF-8"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123;</span><br><span class="line">    webView.handlerReturnData(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123;</span><br><span class="line">    webView.flushMessageQueue();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.onCustomShouldOverrideUrlLoading(url) ? <span class="keyword">true</span> : <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面着重分析一下 JS 和 Native 相互调用的流程。</p><h3 id="JS-调-Native-流程分析"><a href="#JS-调-Native-流程分析" class="headerlink" title="JS 调 Native 流程分析"></a>JS 调 Native 流程分析</h3><p>首先，在 Native 端通过 registerHandler 方法注册一个特定 Handler，或者通过 setdefaultHandler 方法注册一个默认 Handler。这里使用了一个 Map 对象保存 Handler，后续通过 Handler 的名字就可以找到对应的 Handler，如果 Handler 的名字为空，则取默认的 Handler。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String handlerName, BridgeHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加至 Map&lt;String, BridgeHandler&gt;</span></span><br><span class="line">    messageHandlers.put(handlerName, handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultHandler</span><span class="params">(BridgeHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.defaultHandler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，JS 端通过 callHandler 或 send 方法开始调用 Native：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123;</span><br><span class="line">  _doSend(&#123;</span><br><span class="line">    handlerName: handlerName,</span><br><span class="line">    data: data</span><br><span class="line">  &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">  _doSend(&#123;</span><br><span class="line">    data: data</span><br><span class="line">  &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">    <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span> + (uniqueId++) + <span class="string">'_'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">    message.callbackId = callbackId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sendMessageQueue.push(message);</span><br><span class="line">  messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS 端会生成一个唯一的 callbackId，用于保存 JS 回调函数，然后把消息添加到 JS 的消息队列，这个消息包含三个字段，分别是 handlerName、data 和 callbackId。最后通过刷新 iframe 的 src 属性 <code>yy://__QUEUE_MESSAGE__/</code>与 Native 通信。Native 拦截到这个 url，执行 <code>flushMessageQueue()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">    loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, <span class="keyword">new</span> CallBackFunction() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反序列化消息，处理消息</span></span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUrl</span><span class="params">(String jsUrl, CallBackFunction returnCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadUrl(jsUrl);</span><br><span class="line">  <span class="comment">// 添加至 Map&lt;String, CallBackFunction&gt;</span></span><br><span class="line">  responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上是执行了 <code>_fetchQueue()</code> 这个 JS 函数，同时保存 Native 的回调函数到 Map 对象，方便后续处理 <code>_fetchQueue()</code> 返给 Native 的数据。接下来看看 <code>_fetchQueue()</code> 这个 JS 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_fetchQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(sendMessageQueue);</span><br><span class="line">  sendMessageQueue = [];</span><br><span class="line">  <span class="keyword">if</span> (messageQueueString !== <span class="string">'[]'</span>) &#123;</span><br><span class="line">    bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://return/_fetchQueue/'</span> + <span class="built_in">encodeURIComponent</span>(messageQueueString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它从 JS 的消息队列获取消息，转换成 JSON 字符串，然后通过刷新 iframe 的 src 属性 <code>yy://return/_fetchQueue/messageQueueString</code>与 Native 通信，其中 messageQueueString 是消息列表的 JSON 字符串表示，示例如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"handlerName"</span>:<span class="string">"submitFromWeb"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"param"</span>:<span class="string">"test"</span>&#125;,<span class="attr">"callbackId"</span>:<span class="string">"cb_1_1552271280189"</span>&#125;]</span><br></pre></td></tr></table></figure><p>Native 拦截到这个 url，执行 <code>handlerReturnData(url)</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerReturnData</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">  String functionName = BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line">  CallBackFunction f = responseCallbacks.get(functionName);</span><br><span class="line">  String data = BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line">  <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">    f.onCallBack(data);</span><br><span class="line">    responseCallbacks.remove(functionName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会从 url 中取出方法名和数据，再从 Map 里取出该方法名对应的 Native 回调函数，这里实际上就是  <code>flushMessageQueue</code> 方法里设置的匿名 CallBackFunction，它会把 JSON 格式的数据反序列化成消息列表，挨个处理消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 反序列化消息，处理消息</span></span><br><span class="line">  List&lt;Message&gt; list = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = Message.toArrayList(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Message m = list.get(i);</span><br><span class="line">    String responseId = m.getResponseId();</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(responseId)) &#123;</span><br><span class="line">      <span class="comment">// Native 调 JS 时，执行 Native 回调</span></span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// JS 调 Native 时，Native 处理 JS 传过来的数据</span></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于消息里只包含 handlerName、data、callbackId 这三个字段，没有 responseId，因此走的是 else 这个分支，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CallBackFunction responseFunction = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> String callbackId = m.getCallbackId();</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(callbackId)) &#123;</span><br><span class="line">  responseFunction = <span class="keyword">new</span> CallBackFunction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      Message responseMsg = <span class="keyword">new</span> Message();</span><br><span class="line">      responseMsg.setResponseId(callbackId);</span><br><span class="line">      responseMsg.setResponseData(data);</span><br><span class="line">      queueMessage(responseMsg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  responseFunction = <span class="keyword">new</span> CallBackFunction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BridgeHandler执行</span></span><br><span class="line">BridgeHandler handler;</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(m.getHandlerName())) &#123;</span><br><span class="line">  handler = messageHandlers.get(m.getHandlerName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  handler = defaultHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>)&#123;</span><br><span class="line">  handler.handler(m.getData(), responseFunction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据消息里的 handlerName 从 Map 里找到注册的 Handler，在 Handler 里处理 JS 传过来的 data，并执行 responseFunction.onCallBack(responseData) 将响应数据回给 JS，这里主要看一下 <code>queueMessage</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueMessage</span><span class="params">(Message m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (startupMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startupMessage.add(m);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatchMessage(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startupMessage 在 onPageFinished 会被设置为 null，如果其不为 null，说明页面还在加载中，把消息保存到消息列表，等页面加载完成时，再将消息逐个取出进行分发。分发消息执行 <code>dispatchMessage</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message m)</span> </span>&#123;</span><br><span class="line">  String messageJson = m.toJson();</span><br><span class="line">  <span class="comment">//escape special characters for json string  为json字符串转义特殊字符</span></span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"(\\\\)([^utrn])"</span>, <span class="string">"\\\\\\\\$1$2"</span>);</span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"(?&lt;=[^\\\\])(\")"</span>, <span class="string">"\\\\\""</span>);</span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"(?&lt;=[^\\\\])(\')"</span>, <span class="string">"\\\\\'"</span>);</span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"%7B"</span>, URLEncoder.encode(<span class="string">"%7B"</span>));</span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"%7D"</span>, URLEncoder.encode(<span class="string">"%7D"</span>));</span><br><span class="line">  messageJson = messageJson.replaceAll(<span class="string">"%22"</span>, URLEncoder.encode(<span class="string">"%22"</span>));</span><br><span class="line">  String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class="line">  <span class="comment">// 必须要找主线程才会将数据传递出去 --- 划重点</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadUrl(javascriptCommand);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在分发消息时，实际上是执行了 <code>_handleMessageFromNative()</code> 这个 JS 函数，由于把消息转成 JSON 字符串了，所以在拼接要执行的 JS 时需要进行特殊字符转义。消息的 JSON 字符串示例如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"responseData"</span>:<span class="string">"response data from Java"</span>,<span class="attr">"responseId"</span>:<span class="string">"cb_2_1552272760106"</span>&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <code>_handleMessageFromNative()</code> 这个 JS 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_handleMessageFromNative</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(messageJSON);</span><br><span class="line">  <span class="keyword">if</span> (receiveMessageQueue) &#123;</span><br><span class="line">    receiveMessageQueue.push(messageJSON);</span><br><span class="line">  &#125;</span><br><span class="line">  _dispatchMessageFromNative(messageJSON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_dispatchMessageFromNative</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(messageJSON);</span><br><span class="line">    <span class="keyword">var</span> responseCallback;</span><br><span class="line">    <span class="keyword">if</span> (message.responseId) &#123;</span><br><span class="line">      <span class="comment">// JS 调 Native 时，执行 JS 回调</span></span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Native 调 JS 时，JS 处理 Native 传过来的数据</span></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>receiveMessageQueue 在 JS 调用 init 方法时会被设置为 null，如果其不为 null，说明还没有调用 init 方法，在这种情况下，消息会被保存到 receiveMessageQueue，等到调用 init 时，再将消息再逐个取出进行分发。分发消息执行 <code>dispatchMessage</code>方法。由于消息里只包含 responseData 和 responseId 这两个字段，因此走的是 if 这个分支，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">responseCallback = responseCallbacks[message.responseId];</span><br><span class="line"><span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">responseCallback(message.responseData);</span><br><span class="line"><span class="keyword">delete</span> responseCallbacks[message.responseId];</span><br></pre></td></tr></table></figure><p>根据 responseId 取出  JS 回调函数，然后执行 JS 回调。这个 responseId 实际就是最开始 JS 调 Native 时由 JS 生成的唯一的 callbackId，JS 将其传递给 Native 之后，Native 将其放到 responseId 字段里又传回给 JS。</p><p>至此，整个 JS 调 Native 的流程结束。详细流程如下图：</p><div id="sequence-0"></div><h3 id="Native-调-JS-流程分析"><a href="#Native-调-JS-流程分析" class="headerlink" title="Native 调 JS 流程分析"></a>Native 调 JS 流程分析</h3><p>首先，在 JS 端通过 registerHandler 方法注册一个特定 Handler，或者通过 init 方法注册一个默认的 Handler。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerHandler</span>(<span class="params">handlerName, handler</span>) </span>&#123;</span><br><span class="line">  messageHandlers[handlerName] = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">messageHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (WebViewJavascriptBridge._messageHandler) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'WebViewJavascriptBridge.init called twice'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  WebViewJavascriptBridge._messageHandler = messageHandler;</span><br><span class="line">  <span class="keyword">var</span> receivedMessages = receiveMessageQueue;</span><br><span class="line">  receiveMessageQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; receivedMessages.length; i++) &#123;</span><br><span class="line">    _dispatchMessageFromNative(receivedMessages[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，Native 端通过 callHandler 或 send 方法开始调用 JS。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callHandler</span><span class="params">(String handlerName, String data, CallBackFunction callBack)</span> </span>&#123;</span><br><span class="line">  doSend(handlerName, data, callBack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">  send(data, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String data, CallBackFunction responseCallback)</span> </span>&#123;</span><br><span class="line">  doSend(<span class="keyword">null</span>, data, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSend</span><span class="params">(String handlerName, String data, CallBackFunction responseCallback)</span> </span>&#123;</span><br><span class="line">  Message m = <span class="keyword">new</span> Message();</span><br><span class="line">  <span class="keyword">if</span> (!TextUtils.isEmpty(data)) &#123;</span><br><span class="line">    m.setData(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (responseCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class="line">    responseCallbacks.put(callbackStr, responseCallback);</span><br><span class="line">    m.setCallbackId(callbackStr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class="line">    m.setHandlerName(handlerName);</span><br><span class="line">  &#125;</span><br><span class="line">  queueMessage(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Native 端会生成一个唯一的 callbackId，用于保存 Native 回调函数。然后通过 <code>queueMessage</code> 方法分发消息，这个消息包含三个字段，分别是 handlerName、data 和 callbackId。消息 JSON 示例如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"callbackId"</span>:<span class="string">"JAVA_CB_3_973"</span>, <span class="attr">"data"</span>:<span class="string">"data from Java"</span>, <span class="attr">"handlerName"</span>:<span class="string">"functionInJs"</span>&#125;</span><br></pre></td></tr></table></figure><p><code>queueMessage</code> 方法前面已经分析过，它实际上是执行了 <code>_handleMessageFromNative()</code> 这个 JS 函数。由于消息里不包含 responseId 字段，因此走的是 else 分支，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (message.callbackId) &#123;</span><br><span class="line">  <span class="keyword">var</span> callbackResponseId = message.callbackId;</span><br><span class="line">  responseCallback = <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">    _doSend(&#123;</span><br><span class="line">      responseId: callbackResponseId,</span><br><span class="line">      responseData: responseData</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = WebViewJavascriptBridge._messageHandler;</span><br><span class="line"><span class="keyword">if</span> (message.handlerName) &#123;</span><br><span class="line">  handler = messageHandlers[message.handlerName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找指定handler</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  handler(message.data, responseCallback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">console</span> != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebViewJavascriptBridge: WARNING: javascript handler threw."</span>, message, exception);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 JS 代码主要是处理 Native 传过来的数据，根据 handlerName 查找 JS 注册的对应的 Handler，然后通过 _doSend 方法将响应数据回给 Native，最后执行 Native 回调。</p><p>具体流程跟前面分析的 JS 调  Native 的流程基本一致，先往 JS 消息队列添加消息，然后通知 Native 端执行 flushMessageQueue 去刷新消息队列。只不过这里的消息只有 responseId 和 responseData 字段，而这个 responseId 实际就是最开始 Native 调 JS 时由 Native 生成的唯一的 callbackId，Native 将其传递给 JS 之后，JS 将其放到 responseId 字段里又传回给 Native，Native 根据 responseId 找到对应的回调函数，执行回调。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(responseId)) &#123;</span><br><span class="line">  CallBackFunction function = responseCallbacks.get(responseId);</span><br><span class="line">  String responseData = m.getResponseData();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != function) &#123;</span><br><span class="line">    function.onCallBack(responseData);</span><br><span class="line">  &#125;</span><br><span class="line">  responseCallbacks.remove(responseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个 Native 调 JS 的流程结束。详细流程如下图：</p><div id="sequence-1"></div><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><h3 id="JS-和-Native-的通信机制"><a href="#JS-和-Native-的通信机制" class="headerlink" title="JS 和 Native 的通信机制"></a>JS 和 Native 的通信机制</h3><p>JS 给 Native 发消息主要是向 body 中添加一个不可见的 iframe 元素，通过刷新 iframe 的 src 属性，然后就可以让 WebView 在 shouldOverrideUrlLoading 拦截到特殊格式的 url，从而获取到 JS 传递给 Native 的参数，执行不同的 Native 方法。同时，由于页面本身不跳转，用户无感知。</p><p>JS 给 Native 发消息主要分成两步，第一步先将消息添加到 JS 消息队列，然后发消息通知 Native 去刷新其消息队列，Native 通过 loadUrl 执行 JS 函数 <code>_fetchQueue</code>。第二步从消息队列一次性取出所有消息，再通过 url 的方式传递给 Native，Native 收到消息后一个一个串行处理。</p><p>Native 给 JS 发消息主要是通过 loadUrl 执行 JS。最主要的就是 <code>_handleMessageFromNative</code>， 将 Native 参数传递给 JS。</p><h3 id="JS-和-Native-的实现逻辑"><a href="#JS-和-Native-的实现逻辑" class="headerlink" title="JS 和 Native 的实现逻辑"></a>JS 和 Native 的实现逻辑</h3><p>通过分析 JS 调 Native 以及 Native 调 JS 的流程，发现在 JS 端和 Native 端的实现非常类似，基本上是用 JavaScript 和 Java 实现了类似的逻辑。</p><p>例如在调用开始时，均需要生成一个唯一的回调 Id，用来保存本端的回调函数。</p><p>另外，在消息的处理逻辑上，两端也很类似，如果消息里包含 responseId 则执行本端的回调函数，否则处理另一端传过来的数据：根据 handlerName 查找指定的 Handler，将收到的 callbackId 原样存入 responseId 字段再回给另一端，以执行另一端的回调函数。</p><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>JS 和 Native 端的实现都使用了队列这个数据结构。</p><ul><li><p>Native 消息队列</p><p>Native 的 <code>queueMessage</code> 方法，当页面没有加载完成时，将消息先保存到队列，等页面加载完成时再挨个分发队列里的消息。这样可以避免在页面未加载完成时进行一些操作导致的异常。</p></li><li><p>JS 消息队列</p><p>当 JS 端没有调用 <code>init</code> 方法时，Native 通过 <code>send</code> 方法给 JS 发消息时，消息并不会立即被处理，而是先保存到队列，等 JS 端调用 <code>init</code> 方法时，再创建默认的 Handler，然后挨个分发队列里的消息。</p><p>当 JS 通过 <code>_doSend</code> 方法给 Native 发消息时，消息也是先加到 JS 消息队列里，然后再通知 Native 执行 JS，最后 一次性从 JS 消息队列里取出所有的消息传给 Native。<br><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant JSparticipant Nativenote over JS: callHandler(handlerName, data, responseCallback)note over JS: _doSend({\nhandlerName: handlerName,\ndata: data\n}, responseCallback)note over JS: responseCallbacks[callbackId]=responseCallback\nsendMessageQueue.push(message)JS->Native: iframe.src=yy://__QUEUE_MESSAGE__/note over Native: shouldOverrideUrlLoading()note over Native: flushMessageQueue()Native->JS: loadUrl("javascript:_fetchQueue();")note over JS: _fetchQueue()note over JS: messageQueueString=JSON.stringify(sendMessageQueue)\nsendMessageQueue=[]note over JS: messageQueueString Example：\n[{"handlerName":"submitFromWeb",\n"data":{"param":"test"},\n"callbackId":"cb_1_1552271280189"}]JS->Native: iframe.src=yy://return/_fetchQueue/[messageQueueString]note over Native: shouldOverrideUrlLoading()note over Native: handlerReturnData()note over Native: handler.handler(message.getData(), responseFunction)note over Native: responseFunction.onCallBack(responseData from Java)note over Native: queueMessage(responseMsg)note over Native: dispatchMessage(responseMsg)note over Native: messageJson Example:\n{"responseData":"response data from Java",\n"responseId":"cb_1_1552271280189"}Native->JS: loadUrl("javascript:_handleMessageFromNative(messageJson);")note over JS: _handleMessageFromNative(messageJson)note over JS: _dispatchMessageFromNative(messageJson)note over JS: responseCallback=responseCallbacks[message.responseId)\nresponseCallback(message.responseData)</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">participant JSparticipant Nativenote over Native: callHandler(handlerName, data, responseCallback)note over Native: doSend(handlerName, data, responseCallback)note over Native: responseCallbacks.put(callbackId, responseCallback);note over Native: queueMessage(message)note over Native: dispatchMessage(message)note over Native: messageJson Example:\n{"callbackId":"JAVA_CB_3_973",\n"data":"data from Java",\n"handlerName":"functionInJs"}Native->JS: loadUrl("javascript:_handleMessageFromNative(messageJson);")note over JS: _handleMessageFromNative(messageJson)note over JS: _dispatchMessageFromNative(messageJson)note over JS: handler(message.data, responseCallback)note over JS: responseCallback(responseData from JS)note over JS: _doSend({responseId: callbackResponseId,\nresponseData: responseData})note over JS: sendMessageQueue.push(message)JS->Native: iframe.src=yy://__QUEUE_MESSAGE__/note over Native: shouldOverrideUrlLoading()note over Native: flushMessageQueue()Native->JS: loadUrl("javascript:_fetchQueue();")note over JS: _fetchQueue()note over JS: messageQueueString = JSON.stringify(sendMessageQueue)\nsendMessageQueue = []note over JS: messageQueueString Example：\n[{"responseId":"JAVA_CB_3_973","responseData":"Javascript response data"}]JS->Native: iframe.src=yy://return/_fetchQueue/[messageQueueString]note over Native: shouldOverrideUrlLoading()note over Native: handlerReturnData()note over Native: CallBackFunction function = responseCallbacks.get(message.getResponseId())\nfunction.onCallBack(message.getResponseData())\nresponseCallbacks.remove(responseId)</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了 JsBridge 的使用，并基于源码详细分析了 JS 和 Native 的相互调用流程。最后，简单谈了谈对 JsBridge 的一些理解，包括其通信机制、实现逻辑等。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://andavid.github.io/categories/Android/"/>
    
    
      <category term="JsBridge" scheme="https://andavid.github.io/tags/JsBridge/"/>
    
  </entry>
  
  <entry>
    <title>Git 简明指南</title>
    <link href="https://andavid.github.io/2019/01/16/git-guide/"/>
    <id>https://andavid.github.io/2019/01/16/git-guide/</id>
    <published>2019-01-16T08:48:18.000Z</published>
    <updated>2019-07-15T01:54:28.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。</p><a id="more"></a><h2 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录（workspace），它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。</p><p><img src="/2019/01/16/git-guide/trees.png" alt=""></p><p>git 状态的转换如下图所示：</p><p><img src="/2019/01/16/git-guide/workflow.jpg" alt=""></p><h2 id="Git-内部实现原理"><a href="#Git-内部实现原理" class="headerlink" title="Git 内部实现原理"></a>Git 内部实现原理</h2><p>Git 是一个内容寻址文件系统。</p><p>Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p><p>每一次提交对应 .git/objects 目录下的一个文件。以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>所有的提交以树的方式组织在一起。</p><p>HEAD, master, 分支名，标记，都是一个指针指向某一次提交。</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>了解以上 Git 工作流和 Git 内部实现原理，有助于更好的使用 Git。为了更好的使用 Git，需要对 Git 进行一些简单的配置。</p><p>查看当前配置的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --lis</span><br></pre></td></tr></table></figure><p>设置提交用户名和邮箱：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;mail@gmail.com&quot;</span><br></pre></td></tr></table></figure><p>设置所有的 git pull 命令使用 git rebase 而不是 git merge：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global pull.rebase true</span><br></pre></td></tr></table></figure><p>设置别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias.st=status</span><br><span class="line">alias.br=branch</span><br><span class="line">alias.unstage=reset HEAD</span><br><span class="line">alias.last=log -1</span><br><span class="line">alias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class="line">alias.co=checkout</span><br><span class="line">alias.cm=commit -m</span><br></pre></td></tr></table></figure><p>其他配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color.ui=true</span><br><span class="line">core.quotepath=false</span><br><span class="line">core.autocrlf=input</span><br></pre></td></tr></table></figure><p>生成 SSH Key：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后，默认保存位置当前用户名下/.ssh/id_rsa 和 id_rsa.pub，分别是私钥和公钥，可以把公钥添加到远端代码托管平台，这样在使用 Git 时就不用输入密码了。</p><p>GitHub 可以在 <code>设置 -&gt; SSH and GPG Keys</code> 添加 SSH Key。</p><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init                # 创建本地仓库</span><br><span class="line">git clone &lt;server&gt;      # 克隆远程仓库到本地</span><br></pre></td></tr></table></figure><h3 id="添加-amp-删除"><a href="#添加-amp-删除" class="headerlink" title="添加 &amp; 删除"></a>添加 &amp; 删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;              # 添加文件到暂存区</span><br><span class="line">git add .                       # 添加所有修改到暂存区</span><br><span class="line">git rm &lt;filename&gt;               # 直接删除文件</span><br><span class="line">git rm --cached &lt;filename&gt;      # 将文件从暂存区移除</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit message&quot;      # 提交修改</span><br><span class="line">git cherry-pick &lt;commit&gt;...         # 把指定 commit 合并到当前分支，会生成新的 commit</span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;     # 添加远程仓库</span><br><span class="line">git remote -v                      # 查看远程仓库</span><br><span class="line">git push origin master             # 推送到远程 master 分支</span><br><span class="line">git pull origin master             # 从远程仓库拉取更新</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch&gt;                         # 创建分支</span><br><span class="line">git checkout &lt;branch&gt;                       # 切换分支</span><br><span class="line">git checkout -b &lt;branch&gt;                    # 创建并切换到新分支</span><br><span class="line">git checkout -b &lt;branch&gt; &lt;commit&gt;           # 基于某个版本创建新分支</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;    # 创建远程分支到本地</span><br><span class="line">git branch -d &lt;branch&gt;                      # 删除本地分支</span><br><span class="line">git push origin :&lt;branch&gt;                   # 删除远程分支（推送一个空分支到远程分支）</span><br><span class="line">git push origin &lt;branch&gt;                    # 推送本地分支到远程仓库</span><br><span class="line">git merge &lt;branch&gt;                          # 合并分支</span><br><span class="line">git rebase &lt;branch&gt;                         # 分支衍合</span><br><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;      # 建立起本地分支和远程分支的关联，之后可以直接git pull从远程抓取分支</span><br><span class="line">git fetch -p        # 删除远程分支后本地分支同步</span><br></pre></td></tr></table></figure><h3 id="标记管理"><a href="#标记管理" class="headerlink" title="标记管理"></a>标记管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagName&gt;               # 基于当前 HEAD 创建标记</span><br><span class="line">git tag &lt;tagName&gt; &lt;commit&gt;      # 基于指定的 commit id 创建标记</span><br><span class="line">git tag -a &lt;tagName&gt; -m &apos;msg&apos;   # 创建带注释的标记</span><br><span class="line">git checkout &lt;tagName&gt;          # 切换到标记</span><br><span class="line">git push origin &lt;tagName&gt;       # 推送标记到远程仓库</span><br><span class="line">git tag -d &lt;tagName&gt;            # 删除本地标记</span><br><span class="line">git push origin :&lt;tagName&gt;      # 删除远程标记</span><br><span class="line">git tag -l -n1                  # 查看标记列表</span><br></pre></td></tr></table></figure><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log             # 查看提交历史</span><br><span class="line">git show &lt;commit&gt;   # 查看某次修改</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status                      # 查看工作区、暂存区的状态</span><br><span class="line">git clean -fd                   # 删除 untracked files</span><br><span class="line">git checkout -- &lt;file&gt;          # 丢弃工作区上某个文件的修改</span><br><span class="line">git checkout &lt;commit&gt; &lt;file&gt;    # 将某个文件的历史版本 checkout 到工作区</span><br><span class="line">git reset HEAD &lt;file&gt;           # 丢弃暂存区上某个文件的修改，重新放回工作区</span><br><span class="line">git reset --hard &lt;commit&gt;       # 版本回退</span><br><span class="line">git reflog                      # 查看命令历史，常用于帮助找回丢失掉的commit</span><br></pre></td></tr></table></figure><h3 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff              # 查看工作目录和暂存区之间的不同，「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」</span><br><span class="line">git diff --cached     # 查看暂存区和上一条提交之间的不同，「如果你立即输入 git commit，你将会提交什么」</span><br><span class="line">git diff HEAD         # 查看工作目录和上一条提交之间的不同，是上面两个的内容相加，「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」</span><br><span class="line">git diff HEAD -- &lt;file&gt;                     # 查看工作区和版本库里面最新版本的区别</span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only    # 比较两次提交的差异文件列表</span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs zip update.zip          #  比较两次提交的差异，并将所有差异的文件打成一个 zip 包</span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;    # 在合并改动之前，预览两个分支的差异</span><br></pre></td></tr></table></figure><h3 id="储藏和恢复"><a href="#储藏和恢复" class="headerlink" title="储藏和恢复"></a>储藏和恢复</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash           # 把当前分支所有没提交的代码储藏起来</span><br><span class="line">git stash pop       # 恢复工作现场，并删除stash内容</span><br><span class="line">git stash list      # 查看储藏的工作现场</span><br><span class="line">git stash apply     # 恢复工作现场，stash内容并不删除</span><br></pre></td></tr></table></figure><h2 id="Git-分支管理流程"><a href="#Git-分支管理流程" class="headerlink" title="Git 分支管理流程"></a>Git 分支管理流程</h2><p><img src="/2019/01/16/git-guide/git-flow.png" alt=""></p><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>master 分支对应当前生产代码，严禁直接在这个分支上进行开发和提交。</p><h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><ul><li>develop 分支基于 master 分支创建。</li><li>对应开发主分支，只用于做代码同步，不能直接在这个分支进行开发和提交。</li></ul><h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><ul><li>feature 分支基于 develop 分支创建。</li><li>feature 分支用于新功能的开发、bug 修复等日常开发。</li><li>使用 git rebase develop 命令及时合并 develop 分支最新代码，防止和 develop 分支越走越远。</li><li>当合并 develop 分支有冲突时，在 feature 分支进行解决。</li><li>feature 分支开发完成后被合并到 develop 分支。</li></ul><h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><ul><li>release 分支基于 develop 分支创建。</li><li>release 分支作为待发布分支，在这个分支进行回归测试和测试问题的修复。</li><li>release 分支开发完成后被合并到 develop 和 master 分支。</li></ul><h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><ul><li>hotfix 分支基于 master 分支创建。</li><li>hotfix 分支用于生产问题的紧急修复。</li><li>hotfix 分支开发完成后被合并到 develop 和 master 分支。</li></ul><h2 id="代码提交规范"><a href="#代码提交规范" class="headerlink" title="代码提交规范"></a>代码提交规范</h2><ul><li>不在 dev 开发主分支上直接做提交。</li><li>基于 dev 分支创建本地 feature 分支进行提交，包括新功能的开发、bug 修复等。</li><li>每天从服务端拉取 dev 分支最新代码。</li><li>在本地 feature 分支使用 <code>git rebase dev</code> 命令及时合并 dev 分支最新代码，防止本地分支和 dev 分支越走越远。当合并有冲突时，在本地 feature 分支进行解决</li><li>提交代码之前先在本地进行测试，确保项目能编译通过，且能够正常运行，不可盲目提交。</li><li>提交必须要有注释，简要说明本次提交内容。</li><li>尽量提交原子级的操作，便于恢复。不要一次提交 N 多个文件，然后注释写很长还分好几点，如果是这种情况，建议分成多次提交。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://andavid.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://andavid.github.io/tags/git/"/>
    
      <category term="git-flow" scheme="https://andavid.github.io/tags/git-flow/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 中完美插入本地图片</title>
    <link href="https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/"/>
    <id>https://andavid.github.io/2019/01/15/insert-local-image-in-hexo/</id>
    <published>2019-01-15T05:54:39.000Z</published>
    <updated>2019-07-15T01:49:27.250Z</updated>
    
    <content type="html"><![CDATA[<p>在 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">资源文件夹章节</a> 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。</p><a id="more"></a><h2 id="Hexo-官方插入本地图片方法"><a href="#Hexo-官方插入本地图片方法" class="headerlink" title="Hexo 官方插入本地图片方法"></a>Hexo 官方插入本地图片方法</h2><p>首先来看官方给出的几种方式。</p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们统一放在 <code>source/images</code> 文件夹中。然后通过以下方法进行访问。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](/imges/image.jpg)</span><br></pre></td></tr></table></figure><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>图片除了可以放在统一的 <code>source/images</code> 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置  <code>_config.yml</code> 来生成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code> 后，执行命令 <code>hexo new post_name</code>，在 <code>source/_posts</code> 中会生成文章  <code>post_name.md</code> 和同名文件夹 <code>post_name</code>。将图片资源放在  <code>post_name</code> 中，文章就可以使用相对路径引用图片资源了。引用图片的方法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>以上这种引用方法，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><p>引用语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></p><p>在上述语法下，引用图片的方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h2 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h2><p>无论是以上哪一种方法，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a>。先将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code>，然后在根目录下执行以下命令进行插件的安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>通过 <code>hexo new post_name</code> 命令，在 <code>source/_posts</code> 中会自动生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code>，把所有需要插入的图片放到这个同名文件夹里，通过 Markdown 语法对图片的相对路径引用，即可实现编辑时可预览图片，引用方法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](post_name/image.jpg)</span><br></pre></td></tr></table></figure><p>然后在发布时 <code>hexo-asset-image</code> 插件会自动将相对路径转为绝对路径，保证在文章和主页以及归档页都能正常显示图片。</p><p>但是，这个插件有个小问题，如果网站部署在子目录下，插件生成的图片路径有问题，导致图片无法显示。需要修改插件。插件代码主要保存在 <code>node_modules/hexo-asset-image/index.js</code> 这个文件，以下是其中一段代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></figure><p>根据文章链接截取得到 link，其中文章链接一般都是 <code>http://host:port/yyyy/mm/dd/post_name</code>，从第三个 <code>/</code> 后面取到的就是资源的绝对路径，然后对图片的 src 属性进行处理，去掉文章同名文件夹目录，仅保留图片名，然后与前面获取到的资源绝对路径进行拼接，得到图片的绝对路径。</p><p>如果网站部署在子目录下，文章链接是这样的：<br><code>http://host:port/subdirectory/yyyy/mm/dd/post_name</code><br>这时应该从第四个 <code>/</code> 后面开始截取。因此，将代码修改如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">var</span> rootArray = config.root.split(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">2</span> + rootArray.length - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></figure><p>为了使修改后的插件生效，需要先执行 <code>hexo clean</code> 清理一下，然后再执行 <code>hexo g</code> 重新生成即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Hexo 官方插入本地图片的三种方法，但是不推荐使用，因为在使用其他 Markdown 编辑器进行文章编写时，无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 <code>hexo-asset-image</code>，在生成网站时自动将图片相对路径转为绝对路径，使得在文章和主页以及归档页都能正常显示图片。最后，通过修改插件代码，解决网站部署在子目录下图片无法显示的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Hexo 的官方文档 &lt;a href=&quot;https://hexo.io/zh-cn/docs/asset-folders.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;资源文件夹章节&lt;/a&gt; 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://andavid.github.io/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://andavid.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
