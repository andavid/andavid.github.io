<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git 简明指南]]></title>
    <url>%2F2019%2F01%2F16%2Fgit-guide%2F</url>
    <content type="text"><![CDATA[本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。 Git 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录（workspace），它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 git 状态的转换如下图所示： Git 内部实现原理Git 是一个内容寻址文件系统。 Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 每一次提交对应 .git/objects 目录下的一个文件。以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。 所有的提交以树的方式组织在一起。 HEAD, master, 分支名，标记，都是一个指针指向某一次提交。 Git 配置了解以上 Git 工作流和 Git 内部实现原理，有助于更好的使用 Git。为了更好的使用 Git，需要对 Git 进行一些简单的配置。 查看当前配置的命令： git config --lis 设置提交用户名和邮箱： git config --global user.name &quot;username&quot;git config --global user.email &quot;mail@gmail.com&quot; 设置所有的 git pull 命令使用 git rebase 而不是 git merge： git config --global pull.rebase true 设置别名： alias.st=statusalias.br=branchalias.unstage=reset HEADalias.last=log -1alias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitalias.co=checkoutalias.cm=commit -m 其他配置： color.ui=truecore.quotepath=falsecore.autocrlf=input 生成 SSH Key： ssh-keygen -t rsa -C &quot;&quot; 完成后，默认保存位置当前用户名下/.ssh/id_rsa 和 id_rsa.pub，分别是私钥和公钥，可以把公钥添加到远端代码托管平台，这样在使用 Git 时就不用输入密码了。 GitHub 可以在 设置 -&gt; SSH and GPG Keys 添加 SSH Key。 Git 常用命令创建本地仓库git init # 创建本地仓库git clone &lt;server&gt; # 克隆远程仓库到本地 添加 &amp; 删除git add &lt;filename&gt; # 添加文件到暂存区git add . # 添加所有修改到暂存区git rm &lt;filename&gt; # 直接删除文件git rm --cached &lt;filename&gt; # 将文件从暂存区移除 提交git commit -m &quot;commit message&quot; # 提交修改git cherry-pick &lt;commit&gt;... # 把指定 commit 合并到当前分支，会生成新的 commit 远程仓库git remote add origin &lt;server&gt; # 添加远程仓库git remote -v # 查看远程仓库git push origin master # 推送到远程 master 分支git pull origin master # 从远程仓库拉取更新 分支管理git branch &lt;branch&gt; # 创建分支git checkout &lt;branch&gt; # 切换分支git checkout -b &lt;branch&gt; # 创建并切换到新分支git checkout -b &lt;branch&gt; &lt;commit&gt; # 基于某个版本创建新分支git checkout -b &lt;branch&gt; origin/&lt;branch&gt; # 创建远程分支到本地git branch -d &lt;branch&gt; # 删除本地分支git push origin :&lt;branch&gt; # 删除远程分支（推送一个空分支到远程分支）git push origin &lt;branch&gt; # 推送本地分支到远程仓库git merge &lt;branch&gt; # 合并分支git rebase &lt;branch&gt; # 分支衍合git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt; # 建立起本地分支和远程分支的关联，之后可以直接git pull从远程抓取分支git fetch -p # 删除远程分支后本地分支同步 标记管理git tag &lt;tagName&gt; # 基于当前 HEAD 创建标记git tag &lt;tagName&gt; &lt;commit&gt; # 基于指定的 commit id 创建标记git tag -a &lt;tagName&gt; -m &apos;msg&apos; # 创建带注释的标记git checkout &lt;tagName&gt; # 切换到标记git push origin &lt;tagName&gt; # 推送标记到远程仓库git tag -d &lt;tagName&gt; # 删除本地标记git push origin :&lt;tagName&gt; # 删除远程标记git tag -l -n1 # 查看标记列表 查看历史git log # 查看提交历史git show &lt;commit&gt; # 查看某次修改 版本回退git status # 查看工作区、暂存区的状态git clean -fd # 删除 untracked filesgit checkout -- &lt;file&gt; # 丢弃工作区上某个文件的修改git checkout &lt;commit&gt; &lt;file&gt; # 将某个文件的历史版本 checkout 到工作区git reset HEAD &lt;file&gt; # 丢弃暂存区上某个文件的修改，重新放回工作区git reset --hard &lt;commit&gt; # 版本回退git reflog # 查看命令历史，常用于帮助找回丢失掉的commit 查看差异git diff # 查看工作目录和暂存区之间的不同，「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」git diff --cached # 查看暂存区和上一条提交之间的不同，「如果你立即输入 git commit，你将会提交什么」git diff HEAD # 查看工作目录和上一条提交之间的不同，是上面两个的内容相加，「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」git diff HEAD -- &lt;file&gt; # 查看工作区和版本库里面最新版本的区别git diff &lt;commit1&gt; &lt;commit2&gt; --name-only # 比较两次提交的差异文件列表git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs zip update.zip # 比较两次提交的差异，并将所有差异的文件打成一个 zip 包git diff &lt;source_branch&gt; &lt;target_branch&gt; # 在合并改动之前，预览两个分支的差异 储藏和恢复git stash # 把当前分支所有没提交的代码储藏起来git stash pop # 恢复工作现场，并删除stash内容git stash list # 查看储藏的工作现场git stash apply # 恢复工作现场，stash内容并不删除 Git 分支管理流程 master 分支master 分支对应当前生产代码，严禁直接在这个分支上进行开发和提交。 develop 分支 develop 分支基于 master 分支创建。 对应开发主分支，只用于做代码同步，不能直接在这个分支进行开发和提交。 feature 分支 feature 分支基于 develop 分支创建。 feature 分支用于新功能的开发、bug 修复等日常开发。 使用 git rebase develop 命令及时合并 develop 分支最新代码，防止和 develop 分支越走越远。 当合并 develop 分支有冲突时，在 feature 分支进行解决。 feature 分支开发完成后被合并到 develop 分支。 release 分支 release 分支基于 develop 分支创建。 release 分支作为待发布分支，在这个分支进行回归测试和测试问题的修复。 release 分支开发完成后被合并到 develop 和 master 分支。 hotfix 分支 hotfix 分支基于 master 分支创建。 hotfix 分支用于生产问题的紧急修复。 hotfix 分支开发完成后被合并到 develop 和 master 分支。 代码提交规范 不在 dev 开发主分支上直接做提交。 基于 dev 分支创建本地 feature 分支进行提交，包括新功能的开发、bug 修复等。 每天从服务端拉取 dev 分支最新代码。 在本地 feature 分支使用 git rebase dev 命令及时合并 dev 分支最新代码，防止本地分支和 dev 分支越走越远。当合并有冲突时，在本地 feature 分支进行解决 提交代码之前先在本地进行测试，确保项目能编译通过，且能够正常运行，不可盲目提交。 提交必须要有注释，简要说明本次提交内容。 尽量提交原子级的操作，便于恢复。不要一次提交 N 多个文件，然后注释写很长还分好几点，如果是这种情况，建议分成多次提交。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git-guide</tag>
        <tag>git-flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中完美插入本地图片]]></title>
    <url>%2F2019%2F01%2F15%2Finsert-local-image-in-hexo%2F</url>
    <content type="text"><![CDATA[在 Hexo 的官方文档 资源文件夹章节 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。 Hexo 官方插入本地图片方法首先来看官方给出的几种方式。 绝对路径如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们统一放在 source/images 文件夹中。然后通过以下方法进行访问。 ![](/imges/image.jpg) 图片既可以在首页内容中访问到，也可以在文章正文中访问到。 相对路径图片除了可以放在统一的 source/images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 _config.yml 来生成。 post_asset_folder: true 将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。引用图片的方法如下： ![](image.jpg) 以上这种引用方法，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。 标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 引用语法如下：&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 在上述语法下，引用图片的方法如下： &#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 hexo-asset-image无论是以上哪一种方法，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 hexo-asset-image。先将 _config.yml 文件中的配置项 post_asset_folder 设为 true，然后在根目录下执行以下命令进行插件的安装： npm install https://github.com/CodeFalling/hexo-asset-image --save 通过 hexo new post_name 命令，在 source/_posts 中会自动生成文章 post_name.md 和同名文件夹 post_name，把所有需要插入的图片放到这个同名文件夹里，通过 Markdown 语法对图片的相对路径引用，即可实现编辑时可预览图片，引用方法如下： ![](post_name/image.jpg) 然后在发布时 hexo-asset-image 插件会自动将相对路径转为绝对路径，保证在文章和主页以及归档页都能正常显示图片。 但是，这个插件有个小问题，如果网站部署在子目录下，插件生成的图片路径有问题，导致图片无法显示。需要修改插件。插件代码主要保存在 node_modules/hexo-asset-image/index.js 这个文件，以下是其中一段代码： var link = data.permalink;var beginPos = getPosition(link, '/', 3) + 1;// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".var endPos = link.lastIndexOf('/') + 1;link = link.substring(beginPos, endPos); 根据文章链接截取得到 link，其中文章链接一般都是 http://host:port/yyyy/mm/dd/post_name，从第三个 / 后面取到的就是资源的绝对路径，然后对图片的 src 属性进行处理，去掉文章同名文件夹目录，仅保留图片名，然后与前面获取到的资源绝对路径进行拼接，得到图片的绝对路径。 如果网站部署在子目录下，文章链接是这样的：http://host:port/subdirectory/yyyy/mm/dd/post_name这时应该从第四个 / 后面开始截取。因此，将代码修改如下： var link = data.permalink;var rootArray = config.root.split('/');var beginPos = getPosition(link, '/', 2 + rootArray.length - 1) + 1;// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".var endPos = link.lastIndexOf('/') + 1;link = link.substring(beginPos, endPos); 为了使修改后的插件生效，需要先执行 hexo clean 清理一下，然后再执行 hexo g 重新生成即可。 小结本文介绍了 Hexo 官方插入本地图片的三种方法，但是不推荐使用，因为在使用其他 Markdown 编辑器进行文章编写时，无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 hexo-asset-image，在生成网站时自动将图片相对路径转为绝对路径，使得在文章和主页以及归档页都能正常显示图片。最后，通过修改插件代码，解决网站部署在子目录下图片无法显示的问题。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo-insert-local-image</tag>
      </tags>
  </entry>
</search>
