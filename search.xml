<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JsBridge 源码解析]]></title>
    <url>%2F2019%2F03%2F25%2Fjs-bridge%2F</url>
    <content type="text"><![CDATA[本文简单介绍了 JsBridge 的使用，并基于源码详细分析了 JS 和 Native 的相互调用流程。最后，简单谈了谈对 JsBridge 的一些理解，包括其通信机制、实现逻辑等。 项目简介项目地址：https://github.com/lzyzsd/JsBridge JsBridge 是一座用 JavaScript 搭建起来的桥，桥的两端分别是 Native 和 Web。这座桥实现了 Java 和 JavaScript 的数据交换，即 Native 端可以调 Web 的 JS 代码，JS 端也可以调用 Native 的原生代码。 简单使用使用说明这个库会在 onPageFinished 加载一个 JS 文件 WebViewJavascriptBridge.js，这会向 window 对象注入一个 WebViewJavascriptBridge 对象，因此在 JS 中使用 WebViewJavascriptBridge 对象时需检查它是否已经注入，可以通过监听 WebViewJavascriptBridgeReady 事件来实现。 function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge); &#125; else &#123; document.addEventListener( 'WebViewJavascriptBridgeReady' , function() &#123; callback(WebViewJavascriptBridge) &#125;, false ); &#125;&#125; JS 调 Native以下是一个例子，实现按下物理返回键时响应 WebView 的 JS 方法。 首先，在 Native 端通过 registerHandler 方法注册一个设置物理返回键监听的接口供 JS 调用，当按下物理返回键时执行 JS 回调： webview.registerHandler("setPhysicalBackListener", new BridgeHandler() &#123; @Override public void handler(final String data, final CallBackFunction function) &#123; // set physical back key listener // execute function.onCallBack(responseData) when user click physical back key ...... &#125;&#125;); 然后，在 JS 端通过 callHandler 方法调用 Native：connectWebViewJavascriptBridge(function(bridge) &#123; bridge.callHandler( 'setPhysicalBackListener', &#123;&#125;, function(responseData) &#123; alert("back key pressed " + responseData); &#125; );&#125;); JSBridge 也提供了无方法名的调用方式。 首先需要在 Native 端设置一个默认的 Handler： webView.setDefaultHandler(new DefaultHandler()); 然后，在 JS 端通过 send 方法调用 Native： window.WebViewJavascriptBridge.send( data, function(responseData) &#123; &#125;); Native 调 JS以下是一个例子，实现在 Native 端调用在 JS 中定义的 JS 函数。 首先，在 JS 端通过 registerHandler 方法注册一个 Handler： connectWebViewJavascriptBridge(function(bridge) &#123; bridge.registerHandler( "functionInJs", function(data, responseCallback) &#123; document.getElementById("show").innerHTML = ("data from Java: = " + data); if (responseCallback) &#123; var responseData = "Javascript Says Right back aka!"; responseCallback(responseData); &#125; &#125; );&#125;); 然后，在 Native 端通过 callHandler 方法调用： webView.callHandler("functionInJs", new Gson().toJson(user), new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Log.i(TAG, "reponse data from js " + data); &#125;&#125;); 同样的，JSBridge 也提供了无方法名的调用方式。 首先需要在 JS 端设置一个默认的 Handler： connectWebViewJavascriptBridge(function(bridge) &#123; bridge.init(function(message, responseCallback) &#123; console.log('JS got a message', message); var data = &#123; 'Javascript Responds': 'hello' &#125;; if (responseCallback) &#123; console.log('JS responding with', data); responseCallback(data); &#125; &#125;);&#125;); 然后，在 Native 端通过 send 方法调用： webView.send("hello"); 源码解析核心类分析核心的 Java 类主要有两个：BridgeWebView 和 BridgeWebViewClient。 另外，还有一个 WebViewJavascriptBridge.js，主要的 JS 代码都在这个 JS 文件里。 先来看 BridgeWebView 的构造函数： public BridgeWebView(Context context) &#123; super(context); init();&#125;private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125;protected BridgeWebViewClient generateBridgeWebViewClient() &#123; return new BridgeWebViewClient(this);&#125; 初始化时设置了一个自定义的 WebViewClient。 接下来看看 BridgeWebViewClient 这个类： 在 onPageFinished 加载 JS 文件 WebViewJavascriptBridge.js，如果有未发送的消息，挨个取出进行分发。 @Overridepublic void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); if (BridgeWebView.toLoadJs != null) &#123; BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs); &#125; if (webView.getStartupMessage() != null) &#123; for (Message m : webView.getStartupMessage()) &#123; webView.dispatchMessage(m); &#125; webView.setStartupMessage(null); &#125;&#125; 在 shouldOverrideUrlLoading 方法拦截特殊格式的 url，执行 Native 代码。 @Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; webView.flushMessageQueue(); return true; &#125; else &#123; return this.onCustomShouldOverrideUrlLoading(url) ? true : super.shouldOverrideUrlLoading(view, url); &#125;&#125; 下面着重分析一下 JS 和 Native 相互调用的流程。 JS 调 Native 流程分析首先，在 Native 端通过 registerHandler 方法注册一个特定 Handler，或者通过 setdefaultHandler 方法注册一个默认 Handler。这里使用了一个 Map 对象保存 Handler，后续通过 Handler 的名字就可以找到对应的 Handler，如果 Handler 的名字为空，则取默认的 Handler。 public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; // 添加至 Map&lt;String, BridgeHandler&gt; messageHandlers.put(handlerName, handler); &#125;&#125;public void setDefaultHandler(BridgeHandler handler) &#123; this.defaultHandler = handler;&#125; 然后，JS 端通过 callHandler 或 send 方法开始调用 Native： function callHandler(handlerName, data, responseCallback) &#123; _doSend(&#123; handlerName: handlerName, data: data &#125;, responseCallback);&#125;function send(data, responseCallback) &#123; _doSend(&#123; data: data &#125;, responseCallback);&#125;function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; JS 端会生成一个唯一的 callbackId，用于保存 JS 回调函数，然后把消息添加到 JS 的消息队列，这个消息包含三个字段，分别是 handlerName、data 和 callbackId。最后通过刷新 iframe 的 src 属性 yy://__QUEUE_MESSAGE__/与 Native 通信。Native 拦截到这个 url，执行 flushMessageQueue()： void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // 反序列化消息，处理消息 ...... &#125; &#125;); &#125;&#125;public void loadUrl(String jsUrl, CallBackFunction returnCallback) &#123; this.loadUrl(jsUrl); // 添加至 Map&lt;String, CallBackFunction&gt; responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);&#125; 这里实际上是执行了 _fetchQueue() 这个 JS 函数，同时保存 Native 的回调函数到 Map 对象，方便后续处理 _fetchQueue() 返给 Native 的数据。接下来看看 _fetchQueue() 这个 JS 函数： function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; if (messageQueueString !== '[]') &#123; bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125;&#125; 它从 JS 的消息队列获取消息，转换成 JSON 字符串，然后通过刷新 iframe 的 src 属性 yy://return/_fetchQueue/messageQueueString与 Native 通信，其中 messageQueueString 是消息列表的 JSON 字符串表示，示例如下： [&#123;"handlerName":"submitFromWeb","data":&#123;"param":"test"&#125;,"callbackId":"cb_1_1552271280189"&#125;] Native 拦截到这个 url，执行 handlerReturnData(url)： void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125;&#125; 这里会从 url 中取出方法名和数据，再从 Map 里取出该方法名对应的 Native 回调函数，这里实际上就是 flushMessageQueue 方法里设置的匿名 CallBackFunction，它会把 JSON 格式的数据反序列化成消息列表，挨个处理消息。 @Overridepublic void onCallBack(String data) &#123; // 反序列化消息，处理消息 List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); if (!TextUtils.isEmpty(responseId)) &#123; // Native 调 JS 时，执行 Native 回调 ...... &#125; else &#123; // JS 调 Native 时，Native 处理 JS 传过来的数据 ...... &#125; &#125;&#125; 由于消息里只包含 handlerName、data、callbackId 这三个字段，没有 responseId，因此走的是 else 这个分支，具体代码如下： CallBackFunction responseFunction = null;final String callbackId = m.getCallbackId();if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;;&#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;;&#125;// BridgeHandler执行BridgeHandler handler;if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName());&#125; else &#123; handler = defaultHandler;&#125;if (handler != null)&#123; handler.handler(m.getData(), responseFunction);&#125; 根据消息里的 handlerName 从 Map 里找到注册的 Handler，在 Handler 里处理 JS 传过来的 data，并执行 responseFunction.onCallBack(responseData) 将响应数据回给 JS，这里主要看一下 queueMessage 方法： private void queueMessage(Message m) &#123; if (startupMessage != null) &#123; startupMessage.add(m); &#125; else &#123; dispatchMessage(m); &#125;&#125; startupMessage 在 onPageFinished 会被设置为 null，如果其不为 null，说明页面还在加载中，把消息保存到消息列表，等页面加载完成时，再将消息逐个取出进行分发。分发消息执行 dispatchMessage方法： void dispatchMessage(Message m) &#123; String messageJson = m.toJson(); //escape special characters for json string 为json字符串转义特殊字符 messageJson = messageJson.replaceAll("(\\\\)([^utrn])", "\\\\\\\\$1$2"); messageJson = messageJson.replaceAll("(?&lt;=[^\\\\])(\")", "\\\\\""); messageJson = messageJson.replaceAll("(?&lt;=[^\\\\])(\')", "\\\\\'"); messageJson = messageJson.replaceAll("%7B", URLEncoder.encode("%7B")); messageJson = messageJson.replaceAll("%7D", URLEncoder.encode("%7D")); messageJson = messageJson.replaceAll("%22", URLEncoder.encode("%22")); String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson); // 必须要找主线程才会将数据传递出去 --- 划重点 if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; this.loadUrl(javascriptCommand); &#125;&#125; 这里在分发消息时，实际上是执行了 _handleMessageFromNative() 这个 JS 函数，由于把消息转成 JSON 字符串了，所以在拼接要执行的 JS 时需要进行特殊字符转义。消息的 JSON 字符串示例如下： &#123;"responseData":"response data from Java","responseId":"cb_2_1552272760106"&#125; 接下来看看 _handleMessageFromNative() 这个 JS 函数： function _handleMessageFromNative(messageJSON) &#123; console.log(messageJSON); if (receiveMessageQueue) &#123; receiveMessageQueue.push(messageJSON); &#125; _dispatchMessageFromNative(messageJSON);&#125;function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; if (message.responseId) &#123; // JS 调 Native 时，执行 JS 回调 ...... &#125; else &#123; // Native 调 JS 时，JS 处理 Native 传过来的数据 ...... &#125; &#125;);&#125; receiveMessageQueue 在 JS 调用 init 方法时会被设置为 null，如果其不为 null，说明还没有调用 init 方法，在这种情况下，消息会被保存到 receiveMessageQueue，等到调用 init 时，再将消息再逐个取出进行分发。分发消息执行 dispatchMessage方法。由于消息里只包含 responseData 和 responseId 这两个字段，因此走的是 if 这个分支，具体代码如下： responseCallback = responseCallbacks[message.responseId];if (!responseCallback) &#123; return;&#125;responseCallback(message.responseData);delete responseCallbacks[message.responseId]; 根据 responseId 取出 JS 回调函数，然后执行 JS 回调。这个 responseId 实际就是最开始 JS 调 Native 时由 JS 生成的唯一的 callbackId，JS 将其传递给 Native 之后，Native 将其放到 responseId 字段里又传回给 JS。 至此，整个 JS 调 Native 的流程结束。详细流程如下图： Native 调 JS 流程分析首先，在 JS 端通过 registerHandler 方法注册一个特定 Handler，或者通过 init 方法注册一个默认的 Handler。 function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler;&#125;function init(messageHandler) &#123; if (WebViewJavascriptBridge._messageHandler) &#123; throw new Error('WebViewJavascriptBridge.init called twice'); &#125; WebViewJavascriptBridge._messageHandler = messageHandler; var receivedMessages = receiveMessageQueue; receiveMessageQueue = null; for (var i = 0; i &lt; receivedMessages.length; i++) &#123; _dispatchMessageFromNative(receivedMessages[i]); &#125;&#125; 然后，Native 端通过 callHandler 或 send 方法开始调用 JS。 public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack);&#125;public void send(String data) &#123; send(data, null);&#125;public void send(String data, CallBackFunction responseCallback) &#123; doSend(null, data, responseCallback);&#125;private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123; Message m = new Message(); if (!TextUtils.isEmpty(data)) &#123; m.setData(data); &#125; if (responseCallback != null) &#123; String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis())); responseCallbacks.put(callbackStr, responseCallback); m.setCallbackId(callbackStr); &#125; if (!TextUtils.isEmpty(handlerName)) &#123; m.setHandlerName(handlerName); &#125; queueMessage(m);&#125; Native 端会生成一个唯一的 callbackId，用于保存 Native 回调函数。然后通过 queueMessage 方法分发消息，这个消息包含三个字段，分别是 handlerName、data 和 callbackId。消息 JSON 示例如下： &#123;"callbackId":"JAVA_CB_3_973", "data":"data from Java", "handlerName":"functionInJs"&#125; queueMessage 方法前面已经分析过，它实际上是执行了 _handleMessageFromNative() 这个 JS 函数。由于消息里不包含 responseId 字段，因此走的是 else 分支，具体代码如下： if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;;&#125;var handler = WebViewJavascriptBridge._messageHandler;if (message.handlerName) &#123; handler = messageHandlers[message.handlerName];&#125;//查找指定handlertry &#123; handler(message.data, responseCallback);&#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125;&#125; 以上 JS 代码主要是处理 Native 传过来的数据，根据 handlerName 查找 JS 注册的对应的 Handler，然后通过 _doSend 方法将响应数据回给 Native，最后执行 Native 回调。 具体流程跟前面分析的 JS 调 Native 的流程基本一致，先往 JS 消息队列添加消息，然后通知 Native 端执行 flushMessageQueue 去刷新消息队列。只不过这里的消息只有 responseId 和 responseData 字段，而这个 responseId 实际就是最开始 Native 调 JS 时由 Native 生成的唯一的 callbackId，Native 将其传递给 JS 之后，JS 将其放到 responseId 字段里又传回给 Native，Native 根据 responseId 找到对应的回调函数，执行回调。 if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); if (null != function) &#123; function.onCallBack(responseData); &#125; responseCallbacks.remove(responseId);&#125; 至此，整个 Native 调 JS 的流程结束。详细流程如下图： 杂谈JS 和 Native 的通信机制JS 给 Native 发消息主要是向 body 中添加一个不可见的 iframe 元素，通过刷新 iframe 的 src 属性，然后就可以让 WebView 在 shouldOverrideUrlLoading 拦截到特殊格式的 url，从而获取到 JS 传递给 Native 的参数，执行不同的 Native 方法。同时，由于页面本身不跳转，用户无感知。 JS 给 Native 发消息主要分成两步，第一步先将消息添加到 JS 消息队列，然后发消息通知 Native 去刷新其消息队列，Native 通过 loadUrl 执行 JS 函数 _fetchQueue。第二步从消息队列一次性取出所有消息，再通过 url 的方式传递给 Native，Native 收到消息后一个一个串行处理。 Native 给 JS 发消息主要是通过 loadUrl 执行 JS。最主要的就是 _handleMessageFromNative， 将 Native 参数传递给 JS。 JS 和 Native 的实现逻辑通过分析 JS 调 Native 以及 Native 调 JS 的流程，发现在 JS 端和 Native 端的实现非常类似，基本上是用 JavaScript 和 Java 实现了类似的逻辑。 例如在调用开始时，均需要生成一个唯一的回调 Id，用来保存本端的回调函数。 另外，在消息的处理逻辑上，两端也很类似，如果消息里包含 responseId 则执行本端的回调函数，否则处理另一端传过来的数据：根据 handlerName 查找指定的 Handler，将收到的 callbackId 原样存入 responseId 字段再回给另一端，以执行另一端的回调函数。 队列的应用JS 和 Native 端的实现都使用了队列这个数据结构。 Native 消息队列 Native 的 queueMessage 方法，当页面没有加载完成时，将消息先保存到队列，等页面加载完成时再挨个分发队列里的消息。这样可以避免在页面未加载完成时进行一些操作导致的异常。 JS 消息队列 当 JS 端没有调用 init 方法时，Native 通过 send 方法给 JS 发消息时，消息并不会立即被处理，而是先保存到队列，等 JS 端调用 init 方法时，再创建默认的 Handler，然后挨个分发队列里的消息。 当 JS 通过 _doSend 方法给 Native 发消息时，消息也是先加到 JS 消息队列里，然后再通知 Native 执行 JS，最后 一次性从 JS 消息队列里取出所有的消息传给 Native。participant JS participant Native note over JS: callHandler(handlerName, data, responseCallback) note over JS: _doSend({\nhandlerName: handlerName,\ndata: data\n}, responseCallback) note over JS: responseCallbacks[callbackId]=responseCallback\nsendMessageQueue.push(message) JS->Native: iframe.src=yy://__QUEUE_MESSAGE__/ note over Native: shouldOverrideUrlLoading() note over Native: flushMessageQueue() Native->JS: loadUrl("javascript:_fetchQueue();") note over JS: _fetchQueue() note over JS: messageQueueString=JSON.stringify(sendMessageQueue)\nsendMessageQueue=[] note over JS: messageQueueString Example：\n[{"handlerName":"submitFromWeb",\n"data":{"param":"test"},\n"callbackId":"cb_1_1552271280189"}] JS->Native: iframe.src=yy://return/_fetchQueue/[messageQueueString] note over Native: shouldOverrideUrlLoading() note over Native: handlerReturnData() note over Native: handler.handler(message.getData(), responseFunction) note over Native: responseFunction.onCallBack(responseData from Java) note over Native: queueMessage(responseMsg) note over Native: dispatchMessage(responseMsg) note over Native: messageJson Example:\n{"responseData":"response data from Java",\n"responseId":"cb_1_1552271280189"} Native->JS: loadUrl("javascript:_handleMessageFromNative(messageJson);") note over JS: _handleMessageFromNative(messageJson) note over JS: _dispatchMessageFromNative(messageJson) note over JS: responseCallback=responseCallbacks[message.responseId)\nresponseCallback(message.responseData){"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);participant JS participant Native note over Native: callHandler(handlerName, data, responseCallback) note over Native: doSend(handlerName, data, responseCallback) note over Native: responseCallbacks.put(callbackId, responseCallback); note over Native: queueMessage(message) note over Native: dispatchMessage(message) note over Native: messageJson Example:\n{"callbackId":"JAVA_CB_3_973",\n"data":"data from Java",\n"handlerName":"functionInJs"} Native->JS: loadUrl("javascript:_handleMessageFromNative(messageJson);") note over JS: _handleMessageFromNative(messageJson) note over JS: _dispatchMessageFromNative(messageJson) note over JS: handler(message.data, responseCallback) note over JS: responseCallback(responseData from JS) note over JS: _doSend({responseId: callbackResponseId,\nresponseData: responseData}) note over JS: sendMessageQueue.push(message) JS->Native: iframe.src=yy://__QUEUE_MESSAGE__/ note over Native: shouldOverrideUrlLoading() note over Native: flushMessageQueue() Native->JS: loadUrl("javascript:_fetchQueue();") note over JS: _fetchQueue() note over JS: messageQueueString = JSON.stringify(sendMessageQueue)\nsendMessageQueue = [] note over JS: messageQueueString Example：\n[{"responseId":"JAVA_CB_3_973","responseData":"Javascript response data"}] JS->Native: iframe.src=yy://return/_fetchQueue/[messageQueueString] note over Native: shouldOverrideUrlLoading() note over Native: handlerReturnData() note over Native: CallBackFunction function = responseCallbacks.get(message.getResponseId())\nfunction.onCallBack(message.getResponseData())\nresponseCallbacks.remove(responseId){"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("sequence-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-1", options);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JsBridge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 简明指南]]></title>
    <url>%2F2019%2F01%2F16%2Fgit-guide%2F</url>
    <content type="text"><![CDATA[本文作为 Git 简明指南，简单介绍了 Git 工作流和 Git 内部实现原理，然后介绍了 Git 常用的配置，列举了 Git 常用的命令。最后，介绍了经典的 Git 分支管理流程。 Git 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录（workspace），它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 git 状态的转换如下图所示： Git 内部实现原理Git 是一个内容寻址文件系统。 Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 每一次提交对应 .git/objects 目录下的一个文件。以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。 所有的提交以树的方式组织在一起。 HEAD, master, 分支名，标记，都是一个指针指向某一次提交。 Git 配置了解以上 Git 工作流和 Git 内部实现原理，有助于更好的使用 Git。为了更好的使用 Git，需要对 Git 进行一些简单的配置。 查看当前配置的命令： git config --lis 设置提交用户名和邮箱： git config --global user.name &quot;username&quot;git config --global user.email &quot;mail@gmail.com&quot; 设置所有的 git pull 命令使用 git rebase 而不是 git merge： git config --global pull.rebase true 设置别名： alias.st=statusalias.br=branchalias.unstage=reset HEADalias.last=log -1alias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitalias.co=checkoutalias.cm=commit -m 其他配置： color.ui=truecore.quotepath=falsecore.autocrlf=input 生成 SSH Key： ssh-keygen -t rsa -C &quot;&quot; 完成后，默认保存位置当前用户名下/.ssh/id_rsa 和 id_rsa.pub，分别是私钥和公钥，可以把公钥添加到远端代码托管平台，这样在使用 Git 时就不用输入密码了。 GitHub 可以在 设置 -&gt; SSH and GPG Keys 添加 SSH Key。 Git 常用命令创建本地仓库git init # 创建本地仓库git clone &lt;server&gt; # 克隆远程仓库到本地 添加 &amp; 删除git add &lt;filename&gt; # 添加文件到暂存区git add . # 添加所有修改到暂存区git rm &lt;filename&gt; # 直接删除文件git rm --cached &lt;filename&gt; # 将文件从暂存区移除 提交git commit -m &quot;commit message&quot; # 提交修改git cherry-pick &lt;commit&gt;... # 把指定 commit 合并到当前分支，会生成新的 commit 远程仓库git remote add origin &lt;server&gt; # 添加远程仓库git remote -v # 查看远程仓库git push origin master # 推送到远程 master 分支git pull origin master # 从远程仓库拉取更新 分支管理git branch &lt;branch&gt; # 创建分支git checkout &lt;branch&gt; # 切换分支git checkout -b &lt;branch&gt; # 创建并切换到新分支git checkout -b &lt;branch&gt; &lt;commit&gt; # 基于某个版本创建新分支git checkout -b &lt;branch&gt; origin/&lt;branch&gt; # 创建远程分支到本地git branch -d &lt;branch&gt; # 删除本地分支git push origin :&lt;branch&gt; # 删除远程分支（推送一个空分支到远程分支）git push origin &lt;branch&gt; # 推送本地分支到远程仓库git merge &lt;branch&gt; # 合并分支git rebase &lt;branch&gt; # 分支衍合git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt; # 建立起本地分支和远程分支的关联，之后可以直接git pull从远程抓取分支git fetch -p # 删除远程分支后本地分支同步 标记管理git tag &lt;tagName&gt; # 基于当前 HEAD 创建标记git tag &lt;tagName&gt; &lt;commit&gt; # 基于指定的 commit id 创建标记git tag -a &lt;tagName&gt; -m &apos;msg&apos; # 创建带注释的标记git checkout &lt;tagName&gt; # 切换到标记git push origin &lt;tagName&gt; # 推送标记到远程仓库git tag -d &lt;tagName&gt; # 删除本地标记git push origin :&lt;tagName&gt; # 删除远程标记git tag -l -n1 # 查看标记列表 查看历史git log # 查看提交历史git show &lt;commit&gt; # 查看某次修改 版本回退git status # 查看工作区、暂存区的状态git clean -fd # 删除 untracked filesgit checkout -- &lt;file&gt; # 丢弃工作区上某个文件的修改git checkout &lt;commit&gt; &lt;file&gt; # 将某个文件的历史版本 checkout 到工作区git reset HEAD &lt;file&gt; # 丢弃暂存区上某个文件的修改，重新放回工作区git reset --hard &lt;commit&gt; # 版本回退git reflog # 查看命令历史，常用于帮助找回丢失掉的commit 查看差异git diff # 查看工作目录和暂存区之间的不同，「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」git diff --cached # 查看暂存区和上一条提交之间的不同，「如果你立即输入 git commit，你将会提交什么」git diff HEAD # 查看工作目录和上一条提交之间的不同，是上面两个的内容相加，「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」git diff HEAD -- &lt;file&gt; # 查看工作区和版本库里面最新版本的区别git diff &lt;commit1&gt; &lt;commit2&gt; --name-only # 比较两次提交的差异文件列表git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs zip update.zip # 比较两次提交的差异，并将所有差异的文件打成一个 zip 包git diff &lt;source_branch&gt; &lt;target_branch&gt; # 在合并改动之前，预览两个分支的差异 储藏和恢复git stash # 把当前分支所有没提交的代码储藏起来git stash pop # 恢复工作现场，并删除stash内容git stash list # 查看储藏的工作现场git stash apply # 恢复工作现场，stash内容并不删除 Git 分支管理流程 master 分支master 分支对应当前生产代码，严禁直接在这个分支上进行开发和提交。 develop 分支 develop 分支基于 master 分支创建。 对应开发主分支，只用于做代码同步，不能直接在这个分支进行开发和提交。 feature 分支 feature 分支基于 develop 分支创建。 feature 分支用于新功能的开发、bug 修复等日常开发。 使用 git rebase develop 命令及时合并 develop 分支最新代码，防止和 develop 分支越走越远。 当合并 develop 分支有冲突时，在 feature 分支进行解决。 feature 分支开发完成后被合并到 develop 分支。 release 分支 release 分支基于 develop 分支创建。 release 分支作为待发布分支，在这个分支进行回归测试和测试问题的修复。 release 分支开发完成后被合并到 develop 和 master 分支。 hotfix 分支 hotfix 分支基于 master 分支创建。 hotfix 分支用于生产问题的紧急修复。 hotfix 分支开发完成后被合并到 develop 和 master 分支。 代码提交规范 不在 dev 开发主分支上直接做提交。 基于 dev 分支创建本地 feature 分支进行提交，包括新功能的开发、bug 修复等。 每天从服务端拉取 dev 分支最新代码。 在本地 feature 分支使用 git rebase dev 命令及时合并 dev 分支最新代码，防止本地分支和 dev 分支越走越远。当合并有冲突时，在本地 feature 分支进行解决 提交代码之前先在本地进行测试，确保项目能编译通过，且能够正常运行，不可盲目提交。 提交必须要有注释，简要说明本次提交内容。 尽量提交原子级的操作，便于恢复。不要一次提交 N 多个文件，然后注释写很长还分好几点，如果是这种情况，建议分成多次提交。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git-flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中完美插入本地图片]]></title>
    <url>%2F2019%2F01%2F15%2Finsert-local-image-in-hexo%2F</url>
    <content type="text"><![CDATA[在 Hexo 的官方文档 资源文件夹章节 里，提供了几种插入本地图片的方法。但是，非常遗憾，无论采用哪种方式，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。本文介绍了一种方法，可以完美解决此问题。 Hexo 官方插入本地图片方法首先来看官方给出的几种方式。 绝对路径如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们统一放在 source/images 文件夹中。然后通过以下方法进行访问。 ![](/imges/image.jpg) 图片既可以在首页内容中访问到，也可以在文章正文中访问到。 相对路径图片除了可以放在统一的 source/images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 _config.yml 来生成。 post_asset_folder: true 将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。引用图片的方法如下： ![](image.jpg) 以上这种引用方法，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。 标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 引用语法如下：&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 在上述语法下，引用图片的方法如下： &#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 hexo-asset-image无论是以上哪一种方法，在使用其他 Markdown 编辑器进行文章编写时，都无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 hexo-asset-image。先将 _config.yml 文件中的配置项 post_asset_folder 设为 true，然后在根目录下执行以下命令进行插件的安装： npm install https://github.com/CodeFalling/hexo-asset-image --save 通过 hexo new post_name 命令，在 source/_posts 中会自动生成文章 post_name.md 和同名文件夹 post_name，把所有需要插入的图片放到这个同名文件夹里，通过 Markdown 语法对图片的相对路径引用，即可实现编辑时可预览图片，引用方法如下： ![](post_name/image.jpg) 然后在发布时 hexo-asset-image 插件会自动将相对路径转为绝对路径，保证在文章和主页以及归档页都能正常显示图片。 但是，这个插件有个小问题，如果网站部署在子目录下，插件生成的图片路径有问题，导致图片无法显示。需要修改插件。插件代码主要保存在 node_modules/hexo-asset-image/index.js 这个文件，以下是其中一段代码： var link = data.permalink;var beginPos = getPosition(link, '/', 3) + 1;// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".var endPos = link.lastIndexOf('/') + 1;link = link.substring(beginPos, endPos); 根据文章链接截取得到 link，其中文章链接一般都是 http://host:port/yyyy/mm/dd/post_name，从第三个 / 后面取到的就是资源的绝对路径，然后对图片的 src 属性进行处理，去掉文章同名文件夹目录，仅保留图片名，然后与前面获取到的资源绝对路径进行拼接，得到图片的绝对路径。 如果网站部署在子目录下，文章链接是这样的：http://host:port/subdirectory/yyyy/mm/dd/post_name这时应该从第四个 / 后面开始截取。因此，将代码修改如下： var link = data.permalink;var rootArray = config.root.split('/');var beginPos = getPosition(link, '/', 2 + rootArray.length - 1) + 1;// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".var endPos = link.lastIndexOf('/') + 1;link = link.substring(beginPos, endPos); 为了使修改后的插件生效，需要先执行 hexo clean 清理一下，然后再执行 hexo g 重新生成即可。 小结本文介绍了 Hexo 官方插入本地图片的三种方法，但是不推荐使用，因为在使用其他 Markdown 编辑器进行文章编写时，无法预览图片。为了解决此问题，可以安装一个图片路径转换的插件 hexo-asset-image，在生成网站时自动将图片相对路径转为绝对路径，使得在文章和主页以及归档页都能正常显示图片。最后，通过修改插件代码，解决网站部署在子目录下图片无法显示的问题。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
